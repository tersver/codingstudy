# 挑戦1 秘密地図

# へそくりを隠した場所を教えてくれる秘密地図を手に入れた。しかし、この地図は暗号化されて、位置を確認するためには暗号を解読しないといけない。
# 以下は解読するためにメモしたものとなる。

# 1. 地図は一辺の長さがnの正方形配列形態で、各マスは「空白」(" ")または「壁」( "# ")の2種類で構成されている。
# 2. 全体地図は2枚の地図を重ねて得ることができる。 それぞれ「地図1」と「地図2」にしよう、地図1または地図2のいずれか一つでも壁である部分は全体地図でも壁である。 地図1と地図2でいずれも空白の部分は全体地図でも空白だ。
# 3. 「地図1」と「地図2」はそれぞれ整数配列で暗号化されている。
# 4. 暗号化された配列は地図の各横線で壁部分を1、空白部分を0で符号化した時に得られる二進数に該当する値の配列である。

# 秘密地図の暗号を解読するプログラムを作成せよ。

# 入力形式

# 入力で地図の一辺サイズnと2つの整数配列arr1、arr2が入る。

# 1 <= n <= 16
# arr1、arr2は長さnの整数配列で与えられる。
# 整数配列の各元素 x を二進数に変換したときの長さは n 以下である
# つまり、0<=x<=2^n-1を満足する。

# 出力形式
# 元の秘密地図を解読し、「#」、「空白」で構成された文字列配列に出力する。

# 入出力例
# パラメータ値
# n        5
# arr 1   [9,20,28,18,11]
# arr 2   [30, 1, 21, 17, 28]
# 出力    ["#####", "# # #", "### #", "#  ##", "#####"]


# 入出力例
# パラメータ値
# n        6
# arr 1   [46,33,33,22,31,50]
# arr 2   [27, 56, 19, 14, 14, 10]
# 出力    ["######", "###  #", "##  ##", " #### ", " #####", "### # "]

# 解決方法
# 1. 配列1と2の各数字に対して、十進数から二進数に変更する。
# 2. 各行について、or演算を利用して壁と空白部分を探す。
# 4. 結果を出力する。

# コード作成

def solution(n, arr1, arr2):
    result = [[] for a in range(n)]
    index = 0
    for i in range(0, n):
        row1 = [0 for a in range(n)]
        row2 = [0 for a in range(n)]
        index = 0
        original1 = arr1[i]
        original2 = arr2[i]
        while original1 != 0:
            row1[-1 - index] = original1 % 2
            original1 = int(original1 / 2)
            index = index + 1
        index = 0
        while original2 != 0:
            row2[-1 - index] = original2 % 2
            original2 = int(original2 / 2)
            index = index + 1
        row = ""
        for k in range(0, n):
            row = row + "#" if row1[k] | row2[k] else row + " "
        result[i] = row
    print(result)
